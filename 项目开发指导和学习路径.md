# 个人技术博客项目 - 开发指导和学习路径

## 学习目标

通过这个项目，你将掌握：

1. Spring Boot 多数据源配置和管理
2. MySQL、MongoDB、Redis 的综合应用
3. 多线程编程和异步处理
4. 分布式锁和并发控制
5. 缓存策略和性能优化

## 开发步骤和学习路径

### 第一阶段：环境搭建和基础配置 (1-2 天)

#### 1.1 数据库环境准备

```bash
# 安装MySQL
# 创建数据库
CREATE DATABASE blog CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

# 安装MongoDB
# 创建数据库和集合
use blog
db.createCollection("articles")
db.createCollection("comments")

# 安装Redis
# 启动Redis服务
redis-server
```

#### 1.2 配置文件设置

创建 `application.yml` 配置多数据源：

```yaml
spring:
  application:
    name: blog

  # MySQL配置
  datasource:
    mysql:
      url: jdbc:mysql://localhost:3306/blog?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
      username: root
      password: your_password
      driver-class-name: com.mysql.cj.jdbc.Driver

    # Druid连接池配置
    druid:
      initial-size: 5
      min-idle: 5
      max-active: 20
      max-wait: 60000
      validation-query: SELECT 1
      test-while-idle: true

  # MongoDB配置
  data:
    mongodb:
      uri: mongodb://localhost:27017/blog

    # Redis配置
    redis:
      host: localhost
      port: 6379
      timeout: 2000ms
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 0

# MyBatis配置
mybatis:
  mapper-locations: classpath:mapper/*.xml
  type-aliases-package: com.whh.blog.entity

# 线程池配置
async:
  executor:
    core-pool-size: 5
    max-pool-size: 10
    queue-capacity: 1000
    thread-name-prefix: blog-async-
```

**学习重点**：

- 理解多数据源配置原理
- 掌握连接池参数调优
- 了解不同数据库的连接方式

### 第二阶段：数据模型设计 (2-3 天)

#### 2.1 MySQL 实体设计

创建用户和文章基础信息实体：

```java
// User实体 - 存储在MySQL
@Entity
@Table(name = "users")
@Data
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true)
    private String username;

    private String email;
    private String password;

    @CreationTimestamp
    private LocalDateTime createTime;

    @UpdateTimestamp
    private LocalDateTime updateTime;

    @Version
    private Integer version; // 乐观锁
}

// Article实体 - 基础信息存储在MySQL
@Entity
@Table(name = "articles")
@Data
public class Article {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;
    private String summary;
    private Long authorId;
    private String category;
    private Integer viewCount;

    @CreationTimestamp
    private LocalDateTime createTime;

    @UpdateTimestamp
    private LocalDateTime updateTime;

    @Version
    private Integer version;
}
```

#### 2.2 MongoDB 文档设计

```java
// ArticleContent - 文章内容存储在MongoDB
@Document(collection = "article_contents")
@Data
public class ArticleContent {
    @Id
    private String id;

    private Long articleId; // 关联MySQL中的文章ID
    private String content; // Markdown内容
    private List<String> tags;

    @CreatedDate
    private LocalDateTime createTime;

    @LastModifiedDate
    private LocalDateTime updateTime;
}

// Comment - 评论存储在MongoDB
@Document(collection = "comments")
@Data
public class Comment {
    @Id
    private String id;

    private Long articleId;
    private Long userId;
    private String content;
    private String parentId; // 父评论ID，支持嵌套回复
    private Integer likeCount;

    @CreatedDate
    private LocalDateTime createTime;
}
```

**学习重点**：

- 纯 POJO 实体设计
- MyBatis 实体映射原理
- MongoDB 文档设计原则
- 关系型和文档型数据的关联设计

### 第三阶段：MyBatis Mapper 开发 (2-3 天)

#### 3.0 创建 Mapper 接口和 XML 映射文件

```java
// UserMapper接口
@Mapper
public interface UserMapper {

    User selectById(Long id);

    List<User> selectAll();

    int insert(User user);

    int updateById(User user);

    int deleteById(Long id);

    User selectByUsername(String username);

    // 分页查询
    List<User> selectByPage(@Param("offset") int offset, @Param("limit") int limit);

    int countAll();
}

// ArticleMapper接口
@Mapper
public interface ArticleMapper {

    Article selectById(Long id);

    List<Article> selectAll();

    int insert(Article article);

    int updateById(Article article);

    int deleteById(Long id);

    List<Article> selectByAuthorId(Long authorId);

    List<Article> selectByCategory(String category);

    // 乐观锁更新
    int updateByIdWithVersion(@Param("article") Article article, @Param("oldVersion") Integer oldVersion);

    // 增加浏览量
    int incrementViewCount(Long id);
}
```

对应的 XML 映射文件：

```xml
<!-- UserMapper.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.whh.blog.mapper.UserMapper">

    <resultMap id="BaseResultMap" type="com.whh.blog.entity.User">
        <id column="id" property="id" jdbcType="BIGINT"/>
        <result column="username" property="username" jdbcType="VARCHAR"/>
        <result column="email" property="email" jdbcType="VARCHAR"/>
        <result column="password" property="password" jdbcType="VARCHAR"/>
        <result column="create_time" property="createTime" jdbcType="TIMESTAMP"/>
        <result column="update_time" property="updateTime" jdbcType="TIMESTAMP"/>
        <result column="version" property="version" jdbcType="INTEGER"/>
    </resultMap>

    <sql id="Base_Column_List">
        id, username, email, password, create_time, update_time, version
    </sql>

    <select id="selectById" parameterType="java.lang.Long" resultMap="BaseResultMap">
        SELECT <include refid="Base_Column_List"/>
        FROM users
        WHERE id = #{id}
    </select>

    <insert id="insert" parameterType="com.whh.blog.entity.User" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO users (username, email, password, create_time, update_time, version)
        VALUES (#{username}, #{email}, #{password}, NOW(), NOW(), 1)
    </insert>

    <update id="updateById" parameterType="com.whh.blog.entity.User">
        UPDATE users
        SET username = #{username},
            email = #{email},
            update_time = NOW(),
            version = version + 1
        WHERE id = #{id}
    </update>

</mapper>
```

### 第四阶段：多数据源配置 (2-3 天)

#### 3.1 MySQL 数据源配置

```java
@Configuration
@MapperScan(basePackages = "com.whh.blog.mapper", sqlSessionFactoryRef = "mysqlSqlSessionFactory")
public class MysqlConfig {

    @Primary
    @Bean
    @ConfigurationProperties("spring.datasource.druid")
    public DataSource mysqlDataSource() {
        return DruidDataSourceBuilder.create().build();
    }

    @Primary
    @Bean
    public SqlSessionFactory mysqlSqlSessionFactory(@Qualifier("mysqlDataSource") DataSource dataSource) throws Exception {
        SqlSessionFactoryBean bean = new SqlSessionFactoryBean();
        bean.setDataSource(dataSource);
        bean.setMapperLocations(new PathMatchingResourcePatternResolver()
            .getResources("classpath:mapper/*.xml"));

        // 配置MyBatis设置
        org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();
        configuration.setMapUnderscoreToCamelCase(true);
        configuration.setCacheEnabled(true);
        bean.setConfiguration(configuration);

        return bean.getObject();
    }

    @Primary
    @Bean
    public DataSourceTransactionManager mysqlTransactionManager(@Qualifier("mysqlDataSource") DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

#### 3.2 MongoDB 配置

```java
@Configuration
@EnableMongoRepositories(basePackages = "com.whh.blog.repository.mongo")
public class MongoConfig {

    @Bean
    public MongoTransactionManager mongoTransactionManager(MongoDatabaseFactory factory) {
        return new MongoTransactionManager(factory);
    }
}
```

#### 3.3 Redis 配置

```java
@Configuration
@EnableCaching
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);

        // 设置序列化器
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());

        return template;
    }

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30))
            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .build();
    }
}
```

**学习重点**：

- MyBatis 多数据源配置原理
- SqlSessionFactory 配置
- 事务管理器的作用
- Redis 序列化配置

### 第五阶段：多线程配置和异步处理 (3-4 天)

#### 4.1 线程池配置

```java
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {

    @Bean("taskExecutor")
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(1000);
        executor.setThreadNamePrefix("blog-async-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }

    @Override
    public Executor getAsyncExecutor() {
        return taskExecutor();
    }

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return new SimpleAsyncUncaughtExceptionHandler();
    }
}
```

#### 4.2 分布式锁配置

```java
@Configuration
public class RedissonConfig {

    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer()
            .setAddress("redis://localhost:6379")
            .setConnectionMinimumIdleSize(5)
            .setConnectionPoolSize(10);

        return Redisson.create(config);
    }
}
```

#### 4.3 异步服务实现

```java
@Service
@Slf4j
public class AsyncService {

    @Async("taskExecutor")
    public CompletableFuture<Void> updateArticleIndex(Long articleId) {
        log.info("异步更新文章索引: {}", articleId);
        // 模拟耗时操作
        try {
            Thread.sleep(2000);
            // 更新搜索索引逻辑
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return CompletableFuture.completedFuture(null);
    }

    @Async("taskExecutor")
    public void sendNotification(String message) {
        log.info("异步发送通知: {}", message);
        // 发送邮件或消息通知
    }
}
```

**学习重点**：

- 线程池参数调优
- 异步方法的使用
- 分布式锁的应用场景

### 第六阶段：业务逻辑实现 (4-5 天)

#### 6.1 用户服务

```java
@Service
@Transactional
public class UserService {

    @Autowired
    private UserMapper userMapper;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Cacheable(value = "users", key = "#id")
    public User findById(Long id) {
        return userMapper.selectById(id);
    }

    @CacheEvict(value = "users", key = "#user.id")
    public User updateUser(User user) {
        userMapper.updateById(user);
        return userMapper.selectById(user.getId());
    }

    public User createUser(User user) {
        userMapper.insert(user);
        return user; // MyBatis会自动设置生成的ID
    }

    // 分页查询用户
    public PageInfo<User> findUsersByPage(int pageNum, int pageSize) {
        PageHelper.startPage(pageNum, pageSize);
        List<User> users = userMapper.selectAll();
        return new PageInfo<>(users);
    }
}
```

#### 6.2 文章服务（多数据源操作）

```java
@Service
public class ArticleService {

    @Autowired
    private ArticleMapper articleMapper; // MySQL

    @Autowired
    private ArticleContentRepository contentRepository; // MongoDB

    @Autowired
    private AsyncService asyncService;

    @Autowired
    private RedissonClient redissonClient;

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Transactional("mysqlTransactionManager")
    public Article createArticle(ArticleCreateRequest request) {
        // 1. 保存文章基础信息到MySQL
        Article article = new Article();
        article.setTitle(request.getTitle());
        article.setSummary(request.getSummary());
        article.setAuthorId(request.getAuthorId());
        article.setCategory(request.getCategory());
        article.setViewCount(0);
        articleMapper.insert(article);

        // 2. 保存文章内容到MongoDB
        ArticleContent content = new ArticleContent();
        content.setArticleId(article.getId());
        content.setContent(request.getContent());
        content.setTags(request.getTags());
        contentRepository.save(content);

        // 3. 异步更新搜索索引
        asyncService.updateArticleIndex(article.getId());

        return article;
    }

    public void incrementViewCount(Long articleId) {
        RLock lock = redissonClient.getLock("article:view:" + articleId);
        try {
            if (lock.tryLock(1, 10, TimeUnit.SECONDS)) {
                // 使用Redis计数器
                String key = "article:view:count:" + articleId;
                redisTemplate.opsForValue().increment(key);

                // 异步同步到数据库
                asyncService.syncViewCountToDatabase(articleId);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }

    // 乐观锁更新文章
    public boolean updateArticleWithOptimisticLock(Article article) {
        Integer oldVersion = article.getVersion();
        article.setVersion(oldVersion + 1);
        int result = articleMapper.updateByIdWithVersion(article, oldVersion);
        return result > 0;
    }

    // 分页查询文章
    public PageInfo<Article> findArticlesByPage(int pageNum, int pageSize) {
        PageHelper.startPage(pageNum, pageSize);
        List<Article> articles = articleMapper.selectAll();
        return new PageInfo<>(articles);
    }
}
```

**学习重点**：

- MyBatis Mapper 接口的使用
- XML 映射文件编写
- 跨数据源事务处理
- 缓存注解的使用
- 分布式锁的实际应用
- 乐观锁的 MyBatis 实现
- PageHelper 分页插件使用

### 第七阶段：性能优化和监控 (2-3 天)

#### 6.1 缓存策略优化

```java
@Service
public class CacheService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    // 缓存穿透防护
    public Object getWithBloomFilter(String key) {
        // 布隆过滤器检查
        if (!bloomFilter.mightContain(key)) {
            return null;
        }

        Object value = redisTemplate.opsForValue().get(key);
        if (value == null) {
            // 查询数据库
            value = queryFromDatabase(key);
            if (value != null) {
                redisTemplate.opsForValue().set(key, value, Duration.ofMinutes(30));
            }
        }
        return value;
    }

    // 缓存雪崩防护
    public void setWithRandomExpire(String key, Object value) {
        long expire = 1800 + new Random().nextInt(600); // 30-40分钟随机过期
        redisTemplate.opsForValue().set(key, value, Duration.ofSeconds(expire));
    }
}
```

#### 6.2 监控配置

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always
  metrics:
    export:
      prometheus:
        enabled: true
```

**学习重点**：

- 缓存常见问题的解决方案
- 应用监控指标的配置
- 性能调优技巧

### 第八阶段：测试和部署 (2-3 天)

#### 7.1 单元测试

```java
@SpringBootTest
@Testcontainers
class ArticleServiceTest {

    @Container
    static MySQLContainer<?> mysql = new MySQLContainer<>("mysql:8.0")
            .withDatabaseName("blog_test")
            .withUsername("test")
            .withPassword("test");

    @Container
    static MongoDBContainer mongodb = new MongoDBContainer("mongo:5.0");

    @Container
    static GenericContainer<?> redis = new GenericContainer<>("redis:6.2")
            .withExposedPorts(6379);

    @Test
    void testCreateArticle() {
        // 测试文章创建功能
    }

    @Test
    void testConcurrentViewCount() {
        // 测试并发访问计数
    }
}
```

#### 7.2 性能测试

使用 JMeter 或其他工具进行压力测试，重点测试：

- 并发读写性能
- 缓存命中率
- 数据库连接池使用情况
- 线程池使用情况

**学习重点**：

- 集成测试的编写
- 性能测试方法
- 容器化部署

## 学习建议和注意事项

### 学习顺序建议

1. **先理论后实践**：每个阶段开始前先学习相关理论知识
2. **逐步递进**：不要跳跃式开发，确保每个阶段都完全理解
3. **多做实验**：尝试不同的配置参数，观察性能变化
4. **记录问题**：遇到的问题和解决方案要详细记录

### 常见问题和解决方案

1. **数据源配置冲突**：注意@Primary 注解的使用
2. **事务不生效**：检查@Transactional 注解的配置
3. **缓存不生效**：确认@EnableCaching 注解已添加
4. **异步方法不执行**：检查@EnableAsync 配置和方法调用方式

### 扩展学习方向

1. **消息队列**：集成 RabbitMQ 或 Kafka
2. **搜索引擎**：集成 Elasticsearch
3. **微服务**：拆分为多个微服务
4. **容器化**：使用 Docker 部署
5. **监控告警**：集成 Grafana 和 AlertManager

通过这个项目，你将获得多数据库处理和多线程编程的实战经验，为后续的高并发系统开发打下坚实基础。

## 💡 纯 MyBatis 学习的特殊价值

### 为什么选择纯 MyBatis 而不是 JPA？

1. **SQL 控制力更强**

   - 手动编写 SQL，完全控制查询逻辑
   - 更容易进行 SQL 优化和调试
   - 适合复杂查询和报表开发

2. **学习曲线更清晰**

   - 理解 SQL 映射的底层原理
   - 掌握 ResultMap 的配置技巧
   - 学会动态 SQL 的编写

3. **性能优化空间大**

   - 可以针对具体业务编写最优 SQL
   - 避免 ORM 框架的性能损耗
   - 更好地利用数据库特性

4. **企业级项目常用**
   - 大多数企业项目使用 MyBatis
   - 更好的可维护性和可读性
   - 团队协作更容易

### MyBatis 核心学习要点

1. **Mapper 接口设计**：方法命名规范、参数传递
2. **XML 映射文件**：ResultMap 配置、SQL 编写
3. **动态 SQL**：if、choose、foreach 等标签使用
4. **分页处理**：PageHelper 插件的使用
5. **缓存机制**：一级缓存和二级缓存
6. **事务管理**：与 Spring 事务的集成
